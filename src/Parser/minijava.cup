/**
 * CUP specification of the language grammar for a simple demo language.
 * Change this into the language grammar of MiniJava for your implementation.
 *
 * CSE 401/M501/P501 19au, 20sp
 */

package Parser;

import AST.*;
import java.util.*;
import java_cup.runtime.*;

/* Terminals (lexical tokens returned by the scanner): */

/* reserved words */
//terminal DISPLAY;
terminal PRINT;

/* operators */
terminal PLUS, MINUS, MULT, LESS, AND, NOT, BECOMES;

/* delimiters */
terminal LPAREN, RPAREN, LBRACE, RBRACE, LBRACKET, RBRACKET, SEMICOLON, COMMA;

/* types (Type) */
terminal BOOLEAN, INT;

/* truth values (Exp) */
terminal TRUE, FALSE;

/* etc. */
terminal THIS, NEW, CLASS, PUBLIC, STATIC, VOID, MAIN, STRING, EXTENDS, RETURN, WHILE, IF, ELSE, DOT, LENGTH;

/* identifiers */
terminal int INTEGER;
terminal String IDENTIFIER;


/* Nonterminals (constructed by parser): */

nonterminal Program Program;
nonterminal MainClass MainClass;

nonterminal ClassDecl ClassDecl;
nonterminal ClassDeclList ClassDeclList;

nonterminal VarDecl VarDecl;
nonterminal VarDeclList VarDeclList;

nonterminal MethodDecl MethodDecl;
nonterminal MethodDeclList MethodDeclList;

nonterminal Statement Statement;
nonterminal StatementList StatementList;

nonterminal Exp Exp;
nonterminal ExpList NonemptyExpList;
nonterminal ExpList ExpList;

nonterminal Formal Formal;
nonterminal FormalList NonemptyFormalList;
nonterminal FormalList FormalList;

nonterminal ArrayLookup ArrayLookup;
nonterminal ArrayLength ArrayLength;
nonterminal Type Type;
nonterminal Identifier Identifier;


/* Precedence declarations: */

precedence nonassoc BECOMES;
precedence nonassoc AND;
precedence left LESS;
precedence left PLUS, MINUS;
precedence left MULT;
precedence right NOT, NEW;
precedence left DOT;


/* Productions: */

Program ::= MainClass:c ClassDeclList:cs
            {: RESULT = new Program(c, cs, cxleft); :};

MainClass ::= CLASS Identifier:id LBRACE PUBLIC STATIC VOID MAIN LPAREN STRING LBRACKET RBRACKET Identifier:args RPAREN LBRACE Statement:s RBRACE RBRACE
            {: RESULT = new MainClass(id, args, s, idxleft); :};

ClassDecl ::= CLASS Identifier:id LBRACE VarDeclList:vs MethodDeclList:ms RBRACE
            {: RESULT = new ClassDeclSimple(id, vs, ms, idxleft); :}
            | CLASS Identifier:id EXTENDS Identifier:parent LBRACE VarDeclList:vs MethodDeclList:ms RBRACE
            {: RESULT = new ClassDeclExtends(id, parent, vs, ms, idxleft); :};

ClassDeclList ::= ClassDecl:c ClassDeclList:l
            {: RESULT = l; l.add(c); :}
            | /* epsilon */
            {: RESULT = new ClassDeclList(new Location(0, 0)); :};

VarDecl ::= Type:t Identifier:id SEMICOLON
            {: RESULT = new VarDecl(t, id, txleft); :};

VarDeclList ::= VarDeclList:vs VarDecl:v
            {: RESULT = vs; vs.add(v); :}
            | /* epsilon */
            {: RESULT = new VarDeclList(new Location(0, 0)); :};

MethodDecl ::= PUBLIC:p Type:t Identifier:id LPAREN FormalList:params RPAREN LBRACE VarDeclList:vs StatementList:ss RETURN Exp:rv SEMICOLON RBRACE
            {: RESULT = new MethodDecl(t, id, params, vs, ss, rv, idxleft); :};

MethodDeclList ::= MethodDecl:m MethodDeclList:l
            {: RESULT = l; l.add(m); :}
            | /* epsilon */
            {: RESULT = new MethodDeclList(new Location(0, 0)); :};

Statement ::= Identifier:id BECOMES Exp:e SEMICOLON
            {: RESULT = new Assign(id, e, idxleft); :}
            | IF:xIf LPAREN Exp:e RPAREN Statement:sIf ELSE Statement:sElse
            {: RESULT = new If(e, sIf, sElse, xIfxleft); :}
            | PRINT:xPrint LPAREN Exp:e RPAREN SEMICOLON
            {: RESULT = new Print(e, xPrintxleft); :}
            | Identifier:id LBRACKET Exp:e RBRACKET BECOMES Exp:v SEMICOLON
            {: RESULT = new ArrayAssign(id, e, v, idxleft); :}
            | WHILE:xWhile LPAREN Exp:e RPAREN Statement:s
            {: RESULT = new While(e, s, xWhilexleft); :}
            | LBRACE StatementList:ss RBRACE
            {: RESULT = new Block(ss, ssxleft); :};

StatementList ::= Statement:s StatementList:ss
            {: RESULT = ss; ss.add(s); :}
            | /* epsilon */
            {: RESULT = new StatementList(new Location(0, 0)); :};

Exp ::= IDENTIFIER:id
            {: RESULT = new IdentifierExp(id, idxleft); :}
            | Exp:arg1 PLUS Exp:arg2
            {: RESULT = new Plus(arg1, arg2, arg1xleft); :}
            | Exp:arg1 MINUS Exp:arg2
            {: RESULT = new Minus(arg1, arg2, arg1xleft); :}
            | Exp:arg1 MULT Exp:arg2
            {: RESULT = new Times(arg1, arg2, arg1xleft); :}
            | Exp:arg1 LESS Exp:arg2
            {: RESULT = new LessThan(arg1, arg2, arg1xleft); :}
            | Exp:arg1 AND Exp:arg2
            {: RESULT = new And(arg1, arg2, arg1xleft); :}
            | LPAREN Exp:e RPAREN
            {: RESULT = e; :}
            | NOT:not Exp:e
            {: RESULT = new Not(e, notxleft); :}
            | TRUE:xTrue
            {: RESULT = new True(xTruexleft); :}
            | FALSE:xFalse
            {: RESULT = new False(xFalsexleft); :}
            | THIS:xThis
            {: RESULT = new This(xThisxleft); :}
            | NEW:xNew Identifier:id LPAREN RPAREN
            {: RESULT = new NewObject(id, xNewxleft); :}
            | ArrayLength:l
            {: RESULT = l; :}
            | ArrayLookup:l
            {: RESULT = l; :}
            | NEW:xNew INT LBRACKET Exp:e RBRACKET
            {: RESULT = new NewArray(e, xNewxleft); :}
            | Exp:e DOT Identifier:id LPAREN ExpList:args RPAREN
            {: RESULT = new Call(e, id, args, exleft); :}
            | INTEGER:i
            {: RESULT = new IntegerLiteral(i, ixleft); :};

NonemptyExpList ::= Exp:e
            {: RESULT = new ExpList(exleft); RESULT.add(e); :}
            | Exp:e COMMA ExpList:es
            {: RESULT = es; RESULT.add(e); :};

ExpList ::= NonemptyExpList:es
            {: RESULT = es; :}
            | /* epsilon */
            {: RESULT = new ExpList(new Location(0, 0)); :};

Formal ::= Type:t Identifier:id
            {: RESULT = new Formal(t, id, txleft); :};

NonemptyFormalList ::= Formal:f COMMA FormalList:fs
            {: RESULT = fs; fs.add(f); :}
            | Formal:f
            {: RESULT = new FormalList(fxleft); RESULT.add(f); :};

FormalList ::= NonemptyFormalList:fs 
            {: RESULT = fs; :}
            | /* epsilon */
            {: RESULT = new FormalList(new Location(0, 0)); :};

ArrayLookup ::= Exp:array LBRACKET Exp:index RBRACKET
            {: RESULT = new ArrayLookup(array, index, arrayxleft); :};

ArrayLength ::= Exp:array DOT LENGTH
            {: RESULT = new ArrayLength(array, arrayxleft); :};

Type ::= INT:t
            {: RESULT = new IntegerType(txleft); :}
            | BOOLEAN:t
            {: RESULT = new BooleanType(txleft); :}
            | Identifier:id
            {: RESULT = new IdentifierType(id.s, idxleft); :}
            | INT:t LBRACKET RBRACKET
            {: RESULT = new IntArrayType(txleft); :};

Identifier ::= IDENTIFIER: id {: RESULT = new Identifier(id, idxleft); :};
