/**
 * CUP specification of the language grammar for a simple demo language.
 * Change this into the language grammar of MiniJava for your implementation.
 *
 * CSE 401/M501/P501 19au, 20sp
 */

package Parser;

import AST.*;
import java.util.*;
import java_cup.runtime.*;

/* Terminals (lexical tokens returned by the scanner): */

/* reserved words */
//terminal DISPLAY;
terminal PRINT;

/* operators */
terminal PLUS, MINUS, MULT, LESS, AND, NOT, BECOMES;

/* delimiters */
terminal LPAREN, RPAREN, LBRACE, RBRACE, LBRACKET, RBRACKET, SEMICOLON, COMMA;

/* types (Type) */
terminal BOOLEAN, INT;

/* truth values (Exp) */
terminal TRUE, FALSE;

/* etc. */
terminal THIS, NEW, CLASS, PUBLIC, STATIC, VOID, MAIN, STRING, EXTENDS, RETURN, WHILE, IF, ELSE, DOT, LENGTH, EOF;

/* identifiers */
terminal int INTEGER;
terminal String IDENTIFIER;


/* Nonterminals (constructed by parser): */
nonterminal Program Program;
nonterminal MainClass MainClass;

nonterminal MethodDecl MethodDecl;
nonterminal MethodDeclList MethodDeclList;

nonterminal Statement Statement;
nonterminal StatementList StatementList;

nonterminal Exp Exp;
nonterminal ExpList ExpList;

nonterminal ArrayLookup ArrayLookup;
nonterminal ArrayLength ArrayLength;

nonterminal VarDecl VarDeclaration;
nonterminal VarDeclList VarDeclarationList;

nonterminal Formal Formal;
nonterminal FormalList FormalList;

nonterminal ClassDecl ClassDecl;
nonterminal ClassDeclList ClassDeclList;

nonterminal Type Type;
nonterminal Identifier Identifier;


/* Precedence declarations: */

precedence nonassoc BECOMES;
precedence nonassoc AND;
precedence left LT;
precedence left PLUS, MINUS;
precedence left TIMES;
precedence right NOT, NEW;
precedence left DOT;

/* Productions: */

Program ::= MainClass: p ClassDeclList: l EOF
            {:
                RESULT = new Program(p, l, pxleft);
            :}
         |  MainClass: p EOF
            {:
                RESULT = new Program(p, new ClassDeclList(pxleft), pxleft);
            :};

ClassDeclList ::= ClassDeclList: l ClassDecl: c
                         {:
                            l.add(c);
                            RESULT = l;
                         :}
                      |  ClassDecl: c
                        {:
                            ClassDeclList l = new ClassDeclList(cxleft);
                            l.add(c);
                            RESULT = l;
                        :};

MainClass   ::= CLASS Identifier: ai1 LBRACE PUBLIC STATIC VOID MAIN LPAREN STRING LBRACKET RBRACKET Identifier: ai2 RPAREN
                LBRACE Statement: as RBRACE RBRACE
                {:
                    RESULT = new MainClass(ai1, ai2, as, ai1xleft);
                :};

ClassDecl ::= CLASS Identifier: ai LBRACE RBRACE
                        {: RESULT = new ClassDeclSimple(ai, new VarDeclList(aixleft), new MethodDeclList(aixleft), aixleft); :}
                     | CLASS Identifier: ai LBRACE VarDeclList: vl  RBRACE
                        {: RESULT = new ClassDeclSimple(ai, vl , new MethodDeclList(aixleft), aixleft);:}
                     | CLASS Identifier: ai LBRACE MethodDeclList: mdl RBRACE
                        {: RESULT = new ClassDeclSimple(ai, new VarDeclList(aixleft), mdl, aixleft); :}
                     | CLASS Identifier: ai LBRACE VarDeclList: vl MethodDeclList: mdl RBRACE
                        {: RESULT = new ClassDeclSimple(ai, vl, mdl, aixleft); :}
                     | CLASS Identifier: ai EXTENDS Identifier: ai1 LBRACE RBRACE
                        {: RESULT = new ClassDeclExtends(ai, ai1, new VarDeclList(aixleft), new MethodDeclList(aixleft), aixleft); :}
                     | CLASS Identifier: ai EXTENDS Identifier: ai1 LBRACE VarDeclList: vl RBRACE
                        {: RESULT = new ClassDeclExtends(ai, ai1, vl, new MethodDeclList(aixleft), aixleft); :}
                     | CLASS Identifier: ai EXTENDS Identifier: ai1 LBRACE MethodDeclList: mdl RBRACE
                        {: RESULT = new ClassDeclExtends(ai, ai1, new VarDeclList(aixleft), mdl, aixleft); :}
                     | CLASS Identifier: ai EXTENDS Identifier: ai1 LBRACE VarDeclList: vl MethodDeclList: mdl RBRACE
                        {: RESULT = new ClassDeclExtends(ai, ai1, vl, mdl, aixleft); :};

VarDecl ::= Type: t Identifier: id SEMICOLON
                   {: RESULT = new VarDecl(t, id, txleft); :};

VarDeclList ::= VarDeclList: l VarDecl: v
                       {:
                            l.add(v);
                            RESULT = l;
                                                :}
                       |  VarDecl: v
                       {:
                            VarDeclList l = new VarDeclList(vxleft);
                            l.add(v);
                            RESULT = l;
                       :};

MethodDecl ::= ;

MethodDeclList ::= MethodDeclList: l MethodDecl: m
                            {:
                                l.add(m);
                                RESULT = l;
                            :}
                          |  MethodDecl: m
                            {:
                                MethodDeclList l = new MethodDeclList(mxleft);
                                l.add(m);
                                RESULT = l;
                            :};

Type ::= INT: p LBRACKET RBRACKET
            {: RESULT = new IntArrayType(pxleft); :}
         | INT : p
            {: RESULT = new IntegerType(pxleft); :}
         | BOOLEAN: p
            {: RESULT = new BooleanType(pxleft); :}
         | Identifier:id
            {: RESULT = new IdentifierType(id, idxleft); :};

Statement  ::= ;

Exp ::= ;

Identifier ::= IDENTIFIER: id {: RESULT = new Identifier(id, idxleft); :};
