/**
 * CUP specification of the language grammar for a simple demo language.
 * Change this into the language grammar of MiniJava for your implementation.
 *
 * CSE 401/M501/P501 19au, 20sp
 */

package Parser;

import AST.*;
import java.util.*;
import java_cup.runtime.*;

/* Terminals (lexical tokens returned by the scanner): */

/* reserved words */
//terminal DISPLAY;
terminal PRINT;

/* operators */
terminal PLUS, MINUS, MULT, LESS, AND, NOT, BECOMES;

/* delimiters */
terminal LPAREN, RPAREN, LBRACE, RBRACE, LBRACKET, RBRACKET, SEMICOLON, COMMA;

/* types (Type) */
terminal BOOLEAN, INT;

/* truth values (Exp) */
terminal TRUE, FALSE;

/* etc. */
terminal THIS, NEW, CLASS, PUBLIC, STATIC, VOID, MAIN, STRING, EXTENDS, RETURN, WHILE, IF, ELSE, DOT, LENGTH, EOF;

/* identifiers */
terminal int INTEGER;
terminal String IDENTIFIER;


/* Nonterminals (constructed by parser): */
nonterminal Program Program;
nonterminal MainClass MainClass;

nonterminal ClassDecl ClassDecl;
nonterminal ClassDeclList ClassDeclList;

nonterminal VarDecl VarDecl;
nonterminal VarDeclList VarDeclList;

nonterminal MethodDecl MethodDecl;
nonterminal MethodDeclList MethodDeclList;

nonterminal Statement Statement;
nonterminal StatementList StatementList;

nonterminal Exp Exp;
nonterminal ExpList NonemptyExpList;
nonterminal ExpList ExpList;

nonterminal Formal Formal;
nonterminal FormalList NonemptyFormalList;
nonterminal FormalList FormalList;

nonterminal ArrayLookup ArrayLookup;
nonterminal ArrayLength ArrayLength;
nonterminal Type Type;
nonterminal Identifier Identifier;


/* Precedence declarations: */

precedence nonassoc BECOMES;
precedence nonassoc AND;
precedence left LT;
precedence left PLUS, MINUS;
precedence left TIMES;
precedence right NOT, NEW;
precedence left DOT;

/* Productions: */

Program ::= MainClass:c ClassDeclList:cs EOF
            {: RESULT = new Program(c, cs, cxleft); :};

MainClass ::= CLASS Identifier:id LBRACE PUBLIC STATIC VOID MAIN LPAREN STRING LBRACKET RBRACKET Identifier:args RPAREN LBRACE Statement:s RBRACE RBRACE
            {: RESULT = new MainClass(id, args, s, idxleft); :};

ClassDecl ::= CLASS Identifier:id LBRACE VarDeclList:vs MethodDeclList:ms RBRACE
            {: RESULT = new ClassDeclSimple(id, vs, ms, idxleft); :}
            | CLASS Identifier:id EXTENDS Identifier:parent LBRACE VarDeclList:vs MethodDeclList:ms RBRACE
            {: RESULT = new ClassDeclExtends(id, parent, vs, ms, idxleft); :};

ClassDeclList ::= ClassDecl:c ClassDeclList:l
            {: RESULT = l; l.addElement(c); :}
            |
            {: RESULT = new ClassDeclList(0); :};

VarDecl ::= Type:t Identifier:id SEMICOLON
            {: RESULT = new VarDecl(t, id, txleft); :};

VarDeclList ::= VarDeclList:vs VarDecl:v
            {: RESULT = vs; vs.addElement(v); :}
            |
            {: RESULT = new VarDeclList(0); :};

MethodDecl ::= PUBLIC:p Type:t Identifier:id LPAREN FormalList:params RPAREN LBRACE VarDeclList:vs StatementList:ss RETURN Exp:rv SEMICOLON RBRACE
            {: RESULT = new MethodDecl(t, id, params, vs, ss, rv, idxleft); :};

MethodDeclList ::= MethodDecl:m MethodDeclList:l
            {: RESULT = l; l.addElement(m); :}
            |
            {: RESULT = new MethodDeclList(0); :};

Statement ::= Identifier:id BECOMES Exp:e SEMICOLON
            {: RESULT = new Assign(id, e, idxleft); :}
            | IF:if LPAREN Exp:e RPAREN Statement:sIf ELSE Statement:sElse
            {: RESULT = new If(e, sIf, sElse, ifxleft); :}
            | PRINT:print LPAREN Exp:e RPAREN SEMICOLON
            {: RESULT = new Print(e, printxleft); :}
            | Identifier:id LBRACKET Exp:e RBRACKET BECOMES Exp:v SEMICOLON
            {: RESULT = new ArrayAssign(id, e, v, idxleft); :}
            | WHILE:while LPAREN Exp:e RPAREN Statement:s
            {: RESULT = new While(e, s, whilexleft); :}
            | LBRACE StatementList:slist RBRACE
            {: RESULT = new Block(ss, ssxleft); :};

StatementList ::= Statement:s StatementList:ss
            {: RESULT = ss; ss.addElement(s); :}
            |
            {: RESULT = new StatementList(0); :};

Exp ::= IDENTIFIER:id
            {: RESULT = new IdentifierExp(id, idxleft); :}
            | Exp:arg1 PLUS Exp:arg2
            {: RESULT = new Plus(arg1, arg2, arg1xleft); :}
            | Exp:arg1 MINUS Exp:arg2
            {: RESULT = new Minus(arg1, arg2, arg1xleft); :}
            | Exp:arg1 TIMES Exp:arg2
            {: RESULT = new Times(arg1, arg2, arg1xleft); :}
            | Exp:arg1 LESS Exp:arg2
            {: RESULT = new LessThan(arg1, arg2, arg1xleft); :}
            | Exp:arg1 AND Exp:arg2
            {: RESULT = new And(arg1, arg2, arg1xleft); :}
            | LPAREN Exp:e RPAREN
            {: RESULT = e; :}
            | NOT:not Exp:e
            {: RESULT = new Not(e, notxleft); :}
            | TRUE:true
            {: RESULT = new True(truexleft); :}
            | FALSE:false
            {: RESULT = new False(falsexleft); :}
            | THIS:this
            {: RESULT = new This(thisxleft); :}
            | NEW:new Identifier:id LPAREN RPAREN
            {: RESULT = new NewObject(id, newxleft); :}
            | ArrayLength:l
            {: RESULT = l; :}
            | ArrayLookup:l
            {: RESULT = l; :}
            | NEW:new INT LBRACKET Exp:e RBRACKET
            {: RESULT = new NewArray(e, newxleft); :}
            | Exp:e DOT Identifier:id LPAREN ExpList:args RPAREN
            {: RESULT = new Call(e, id, args, exleft); :}
            | INTEGER:i
            {: RESULT = new IntegerLiteral(Integer.parseInt(i), ixleft); :};  // TODO: Is this casting correct?

NonemptyExpList ::= Exp e
            {: RESULT = new ExpList(exleft); RESULT.addElement(e); :}
            | Exp:e COMMA ExpList:es
            {: RESULT = es; RESULT.addElement(e); :};

ExpList ::= NonemptyExpList
            {: RESULT = NonemptyExpList; :}
            |
            {: RESULT = new ExpList(0); :};

Formal ::= Type:t Identifier:id
            {: RESULT = new Formal(t, id, txleft); :};

NonemptyFormalList ::= Formal:f COMMA FormalParameterList:fs
            {: RESULT = fs; fs.addElement(f); :}
            | Formal:f
            {: RESULT = new FormalList(fxleft); RESULT.addElement(f); :};

FormalList ::= NonemptyFormalList:fs 
            {: RESULT = fs; :}
            |
            {: RESULT = new FormalList(0); :};

ArrayLookup ::= Exp:array LBRACKET Exp:index RBRACKET
            {: RESULT = new ArrayLookup(array, index, arrayxleft); :};

ArrayLength ::= Exp:array DOT LENGTH
            {: RESULT = new ArrayLength(array, arrayxleft); :};

Type ::= INT:t
            {: RESULT = new IntegerType(txleft); :}
            | BOOLEAN:t
            {: RESULT = new BooleanType(txleft); :}
            | Identifier:id
            {: RESULT = new IdentifierType(id.s, idxleft); :}
            | INT:t LBRACKET RBRACKET
            {: RESULT = new IntArrayType(txleft); :};

Identifier ::= IDENTIFIER: id {: RESULT = new Identifier(id, idxleft); :};
