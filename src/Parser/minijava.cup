/**
 * CUP specification of the language grammar for a simple demo language.
 * Change this into the language grammar of MiniJava for your implementation.
 *
 * CSE 401/M501/P501 19au, 20sp
 */

package Parser;

import AST.*;
import java.util.*;
import java_cup.runtime.*;

/* Terminals (lexical tokens returned by the scanner): */

/* reserved words */
//terminal DISPLAY;
terminal PRINT;

/* operators */
terminal PLUS, MINUS, MULT, LESS, AND, NOT, BECOMES;

/* delimiters */
terminal LPAREN, RPAREN, LBRACE, RBRACE, LBRACKET, RBRACKET, SEMICOLON, COMMA;

/* types (Type) */
terminal BOOLEAN, INT;

/* truth values (Expression) */
terminal TRUE, FALSE;

/* etc. */
terminal THIS, NEW, CLASS, PUBLIC, STATIC, VOID, MAIN, STRING, EXTENDS, RETURN, WHILE, IF, ELSE, DOT, LENGTH, EOF;

/* identifiers */
terminal int INTEGER;
terminal String IDENTIFIER;


/* Nonterminals (constructed by parser): */

nonterminal Program Program;
nonterminal MainClass MainClass ;
nonterminal ClassDecl ClassDeclaration;
nonterminal ClassDeclList ClassDeclarationList;
nonterminal VarDecl VarDeclaration;
nonterminal VarDeclList VarDeclarationList;
nonterminal MethodDecl MethodDeclaration;
nonterminal MethodDeclList MethodDeclarationList;
nonterminal Type Type;
nonterminal List<Statement> Statement;
nonterminal Exp Expression;
nonterminal Identifier Identifier;


/* Precedence declarations: */

precedence left PLUS;


/* Productions: */

Program ::= MainClass: p ClassDeclarationList: l EOF
            {:
                RESULT = new Program(p, l, pxleft);
            :}
         |  MainClass: p EOF
            {:
                RESULT = new Program(p, new ClassDeclList(pxleft), pxleft);
            :};

ClassDeclarationList ::= ClassDeclarationList: l ClassDeclaration: c
                         {:
                            l.add(c);
                            RESULT = l;
                         :}
                      |  ClassDeclaration: c
                        {:
                            ClassDeclList l = new ClassDeclList(cxleft);
                            l.add(c);
                            RESULT = l;
                        :};
MainClass   ::= CLASS Identifier: ai1 LBRACE PUBLIC STATIC VOID MAIN LPAREN STRING LBRACKET RBRACKET Identifier: ai2 RPAREN
                LBRACE Statement: as RBRACE RBRACE
                {:
                    RESULT = new MainClass(ai1, ai2, as, ai1xleft);
                :};

ClassDeclaration ::= CLASS Identifier: ai LBRACE RBRACE
                        {: RESULT = new ClassDeclSimple(ai, new VerbDeclList(aixleft), new MethodDeclList(aixleft), aixleft); :}
                     | CLASS Identifier: ai LBRACE VarDeclarationList: vl  RBRACE
                        {: RESULT = new ClassDeclSimple(ai, vl , new MethodDeclList(aixleft), aixleft);:}
                     | CLASS Identifier: ai LBRACE MethodDeclarationList: mdl RBRACE
                        {: RESULT = new ClassDeclSimple(ai, new VerbDeclList(aixleft), mdl, aixleft); :}
                     | CLASS Identifier: ai LBRACE VarDeclarationList: vl MethodDeclarationList: mdl RBRACE
                        {: RESULT = new ClassDeclSimple(ai, vl, mdl, aixleft); :}
                     | CLASS Identifier: ai EXTENDS Identifier: ai1 LBRACE RBRACE
                        {: RESULT = new ClassDeclExtends(ai, ai1, new VerbDeclList(aixleft), new MethodDeclList(aixleft), aixleft); :}
                     | CLASS Identifier: ai EXTENDS Identifier: ai1 LBRACE VarDeclarationList: vl RBRACE
                        {: RESULT = new ClassDeclExtends(ai, ai1, vl, new MethodDeclList(aixleft), aixleft); :}
                     | CLASS Identifier: ai EXTENDS Identifier: ai1 LBRACE MethodDeclarationList: mdl RBRACE
                        {: RESULT = new ClassDeclExtends(ai, ai1, new VerbDeclList(aixleft), mdl, aixleft); :}
                     | CLASS Identifier: ai EXTENDS Identifier: ai1 LBRACE VarDeclarationList: vl MethodDeclarationList: mdl RBRACE
                        {: RESULT = new ClassDeclExtends(ai, ai1, vl, mdl, aixleft); :};

VarDeclaration ::= Type: t Identifier: id SEMICOLON
                   {: RESULT = new VarDecl(t, id, txleft); :};

VarDeclarationList ::= VarDeclarationList: l VarDeclaration: v
                       {:
                            l.add(v);
                            RESULT = l;
                                                :}
                       |  VarDeclaration: v
                       {:
                            VarDeclList l = new VarDeclList(vxleft);
                            l.add(v);
                            RESULT = l;
                       :};

MethodDeclaration ::= ;

MethodDeclarationList ::= MethodDeclarationList: l MethodDeclaration: m
                            {:
                                l.add(m);
                                RESULT = l;
                            :}
                          |  MethodDeclaration: m
                            {:
                                MethodDeclList l = new MethodDeclList(mxleft);
                                l.add(v);
                                RESULT = l;
                            :};

Type ::= INT: p LBRACKET RBRACKET
            {: RESULT = new IntArrayType(pxleft); :}
         | INT : p
            {: RESULT = new IntegerType(pxleft); :}
         | BOOLEAN: p
            {: RESULT = new BooleanType(pxleft); :}
         | Identifier:id
            {: RESULT = new IdentifierType(id, idxleft); :};

Statement  ::= ;

Expression ::= ;

Identifier ::= IDENTIFIER: id {: RESULT = new Identifier(id, idxleft); :};
